package middleware

import (
	"crypto/rsa"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"

	jwt "github.com/dgrijalva/jwt-go"
)

var publicKey *rsa.PublicKey

type AutoGenerated struct {
	Fef89Ba72126E54Fdd50C919B7Adb5E26F0299Cf     string `json:"fef89ba72126e54fdd50c919b7adb5e26f0299cf"`
	Three046A15637366B4D64D9A5Abb3373182Ba4D7Cfb string `json:"3046a15637366b4d64d9a5abb3373182ba4d7cfb"`
}

func MiddlewareChain(h http.Handler, middleware ...func(http.Handler) http.Handler) http.Handler {
	for _, mw := range middleware {
		h = mw(h)
	}
	return h
}

func AuthMiddlewareJWT(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var tok *jwt.Token
		var err error
		tok, err = jwt.Parse(r.URL.Query().Get("params"), func(token *jwt.Token) (interface{}, error) {
			resp, err := http.Get("https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com")

			if err != nil {
				return nil, err
			}
			defer resp.Body.Close()

			respBody, err := ioutil.ReadAll(resp.Body)

			if err != nil {
				return nil, err
			}

			var d AutoGenerated
			err = json.Unmarshal(respBody, &d)
			if err != nil {
				log.Println(err.Error())

			}

			publicKey, err = jwt.ParseRSAPublicKeyFromPEM([]byte(d.Three046A15637366B4D64D9A5Abb3373182Ba4D7Cfb))
			if err != nil {
				return nil, err
			}
			return publicKey, nil
		})
		if err != nil {
			log.Println(err.Error())
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		claims := tok.Claims
		log.Println(claims)

		next.ServeHTTP(w, r)
	})
}
